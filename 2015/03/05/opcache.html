<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">

    <title>PHP&#039;s OPCache extension review</title>

    <meta name="description" content="">
    <meta name="author" content="Julien Pauli">
    <meta name="viewport" content="width=device-width">

    
    <link rel="canonical" href="http://jpauli.github.io//2015/03/05/opcache.html"/>
              <link rel="alternate" href="http://jpauli.github.io//feed/atom.xml" type="application/atom+xml" title="Julien Pauli PHP&#039;s life"/>
      
        <!-- Latest compiled and minified CSS --><link rel="stylesheet" href="../../../css/bootstrap.min.css"><link rel="stylesheet" href="../../../css/bootstrap-theme.min.css"><link rel="stylesheet" href="http://yandex.st/highlightjs/8.0/styles/pojoaque.min.css">      </head>

  <body>
          <div class="container">
                  <div class="page-header">
            <ul class="list-inline pull-right">
                                                <li>
                    <a href="../../../about.html">
                      About
                    </a>
                  </li>
                                  <li>
                    <a href="../../../index.html">
                      Welcome to julien pauli&#039;s page
                    </a>
                  </li>
                                          </ul>
            <h1>
              <a href="../../..">
                Julien Pauli PHP&#039;s life
              </a>
            </h1>
          </div>
        
                  <div class="content">
                                          <h1>
                  PHP&#039;s OPCache extension review</h1>
                          
              <article>
    <p class="text-muted">
      <span class="glyphicon glyphicon-calendar"></span>
      Mar 5th, 2015
    </p>

    <div class="body">
      <h2 id="reminder-on-opcodes-caches">Reminder on OPCodes caches<a href="#reminder-on-opcodes-caches" class="anchor">#</a></h2>
<p>PHP is a scripting language, that by default will compile any file you ask it to run, obtain <a href="http://jpauli.github.io/2015/02/05/zend-vm-executor.html">OPCodes</a> from compilation, run them, and trash them away immediately.
PHP has been designed like that : it "forgets" everything it's done in request R-1, when it comes to run request R.</p>
<p>On production servers, the PHP code is very unlikely to change between several requests, thus, the compilation step will always read the same source code, leading to the very exact same OPCode to be run. This is a big waste of time and resources, as the PHP compiler is invoked for every request, for every script.</p>
<p><img src="../../../img/opcache/php-compile-execute-process.png" alt="php-compile-execute-process"></p>
<p>Knowing that compilation can really take a lot of time, OPCode cache extensions have been designed. Their main goal is to <strong>compile once and only once</strong> each PHP script, and cache the resulting OPCodes into shared memory, so that every other PHP worker of your production worker pool (usually using PHP-FPM) can make use of the OPCodes by reading them and executing then back.</p>
<p>The result is a massive boost in overall performance of the language, dividing time to run a script by a factor of at least 2 (very depend on the script), usually more than 2, as PHP now doesn't have to compile again and again the same PHP scripts.</p>
<p>The boost is higher as the application is more complex. If you take applications running tons of files, like framework based applications, or products like wordpress, you will experience a factor of 10-15 or so. This is because the PHP compiler is slow, and this is just a normal situation : a compiler is slow, whatever it is, because its work is to turn a syntax into another, trying to understand what you asked, and somehow to optimize the generated code for it to later run the fastest as possible ; so yes, compiling a PHP script is really slow and eats a lot of memory. Profilers like <a href="https://blackfire.io">Blackfire</a> allows you to know the compile time.</p>
<p><img src="../../../img/opcache/compile-execute.png" alt="compile-time"></p>
<h2 id="introducing-opcache">Introducing OPCache<a href="#introducing-opcache" class="anchor">#</a></h2>
<p>OPCache has been opensourced since 2013, and is bundled into PHP's source starting from PHP 5.5.0
It has thus become a standard for PHP OPcode cache solutions. There exists other solutions, such as XCache, APC, Eaccelerator and others. I will not talk about those other solutions, as I myself don't know them except APC : APC support has been discontinued in favor of OPCache. Short : if you were using APC before, please, use OPCache now.
<strong>OPCache has become the real official recommanded OPCode cache solution by the developpers of PHP</strong>. You may still use other solutions if you want, however, <strong>never ever activate more than one OPCode cache extension at the same time</strong> : you will likely crash PHP.</p>
<p>Be aware that new development involving OPCache won't target PHP 5 branch, but PHP 7 branch which is the nowadays stable branch.
This article will target OPCache for PHP 5 and PHP 7, so that you may spot the differences (which are not that big).</p>
<p>So OPCache is an extension, a <em>zend_extension</em> more precisely, which is shipped into the PHP source code, starting from PHP 5.5.0 (Pecl for others), and that must be activated through the normal php.ini process of activating an extension. For distros, please refer to your distribution manual to know how PHP and OPCache have been bundled.</p>
<h3 id="two-features-into-one-product">Two features into one product<a href="#two-features-into-one-product" class="anchor">#</a></h3>
<p>OPCache is an extension which provides two main features :</p>
<ul><li>OPCodes caching</li>
<li>OPCodes optimization</li>
</ul><p>Because OPCache triggers the PHP compiler, to get OPCodes and cache them, it could use this step to optimize the OPCodes.
Optimizations are basically about compiler optimizations, and share many concepts of this computer science discipline. OPCache optimizer is a multi pass compiler optimizer.</p>
<p><img src="../../../img/opcache/cache-optimization-steps.png" alt="php-compile-execute-process"></p>
<h2 id="opcache-in-deep">OPCache in deep<a href="#opcache-in-deep" class="anchor">#</a></h2>
<p>Let's now see together how OPCache works internally. If you want to follow the code, you can fetch it from the PHP source code, <a href="https://github.com/php/php-src/tree/PHP-7.0/ext/opcache">here it is for PHP 7.0</a>.</p>
<p>Unlike what you can think, OPCode caching is not a that hard concept to analyze and understand. You must have a good knowledge on how the Zend Engine works and has been designed, then you should start spotting places where the job can be done.</p>
<h3 id="shared-memory-models">Shared memory models<a href="#shared-memory-models" class="anchor">#</a></h3>
<p>As you know, there exists many shared memory models under the different Operating Systems. Under modern Unixes, there exists several ways of sharing memory through processes, most commonly used are :</p>
<ul><li>System-V shm API</li>
<li>POSIX API</li>
<li>mmap API</li>
<li>Unix socket API</li>
</ul><p>OPCache is able to use the first three of them, as soon as your OS supports the layer. The INI setting <em>opcache.preferred_memory_model</em> allows you to explicitly select the memory model you want.
If you leave the parameter to null value, OPCache will select the first model which works for your platform, iterating through its table :</p>
<pre><code>static const zend_shared_memory_handler_entry handler_table[] = {
#ifdef USE_MMAP
    { "mmap", &zend_alloc_mmap_handlers },
#endif
#ifdef USE_SHM
    { "shm", &zend_alloc_shm_handlers },
#endif
#ifdef USE_SHM_OPEN
    { "posix", &zend_alloc_posix_handlers },
#endif
#ifdef ZEND_WIN32
    { "win32", &zend_alloc_win32_handlers },
#endif
    { NULL, NULL}
};</code></pre>
<p>So by default, <em>mmap</em> should be used. It's a nice memory model, mature and robust. However it is less informative to sysadmin that System-V SHM model is, and its <code>ipcs</code> and <code>ipcrm</code> commands.</p>
<p>As soon as OPCache starts (as soon as PHP starts), OPCache will try a shared memory model, and will allocate one big memory segment that it will then divide and manage on its side. However, it will never free this segment back, nor will it try to resize it.</p>
<blockquote>
<p>OPCache allocates one segment of shared memory when PHP starts, once for all, and never frees it nor fragments it.</p>
</blockquote>
<p>The size of the memory segment can be told using the <em>opcache.memory_consumption</em> INI setting (Megabytes). Size it big, don't hesitate to give space. <strong>Never ever run out of shared memory space</strong>, if you do, you will lock your processes, we'll get back to that later.</p>
<p>Size the shared memory segment according to your needs, don't forget that a production server dedicated to PHP processes may bundle several dozens of Gigabytes of memory, just for PHP. Having a 1Gb shared memory segment (or more) is not uncommon, it will depend on your needs, but if you use a modern application stack, aka framework based, with lots of dependencies etc... , then use at least 1Gb of shared memory.</p>
<p>The shared memory segment will be used for several things in OPCache :</p>
<ul><li>Script's datastructure caching, involving obviously OPCodes caching but not only</li>
<li>Shared interned strings buffer</li>
<li>Cached scripts HashTable</li>
<li>Global OPCache shared memory state</li>
</ul><p>So remember, the shared memory segment size will not only contain raw OPCodes, but other things needed for OPCache internals.
Measure on your side and size it accordingly.</p>
<p><img src="../../../img/opcache/opcache-shm.png" alt="opcache-shm"></p>
<h3 id="opcodes-caching">OPCodes caching<a href="#opcodes-caching" class="anchor">#</a></h3>
<p>Here we go to detail how the caching mechanism works.</p>
<p>The overall idea is to copy into shared memory (shm) every pointer data that won't change from request to request, aka immutable things. And there are many of them.
After, once loading back the same script : restore every pointer data from shared memory to standard process memory, tied to the current request.
When the PHP compiler is working, it uses Zend Memory Manager (ZMM) to allocate every pointer. This kind of memory used is request bound as ZMM will automaticaly attempt to free those pointers as soon as the current request finishes. Also, those pointers are allocated from the current process' heap, that is this is some privately mapped memory and thus can't be shared with other PHP processes. Hence, OPCache's job is to browse every structure returned by the PHP compiler, and not leave one single pointer allocated onto this pool, but copy it into a shared memory allocated pool.
And here we talk about compile time, whatever has been allocated by the compiler, is assumed to be immutable. Non-immutable data will be created at runtime by the <a href="http://jpauli.github.io/2015/02/05/zend-vm-executor.html">Zend Virtual Machine</a>, so it is safe to save everything that the Zend Compiler created, into shared memory. Examples of such created things : functions and classes, those are functions' name pointers, functions' OPArray pointers, classes' constants, classes's declared variable names and eventually their default content... There are really many things that are created in memory by the PHP compiler.</p>
<p>Such a memory model is used to prevent locks at maximum. We'll go back to locks in a later subject, but basically, OPCache does its job all at once, before runtime, so that during the runtime of the script, OPCache has nothing more to do : volatile data will be created on the classical process heap using ZMM, and immutable data would have been restored from shared memory.</p>
<p>So, OPCache hooks into the compiler, and replaces the structure this latter should fill-in while compiling PHP scripts, by its own.
It then makes the compiler fills a <code>persistent_script</code> structure, instead of it filling directly the Zend Engine tables and internal structures.</p>
<p>Here is a <code>persistent_script</code> structure :</p>
<pre><code>typedef struct _zend_persistent_script {
    ulong          hash_value;
    char          *full_path;              /* full real path with resolved symlinks */
    unsigned int   full_path_len;
    zend_op_array  main_op_array;
    HashTable      function_table;
    HashTable      class_table;
    long           compiler_halt_offset;   /* position of __HALT_COMPILER or -1 */
    int            ping_auto_globals_mask; /* which autoglobals are used by the script */
    accel_time_t   timestamp;              /* the script modification time */
    zend_bool      corrupted;
#if ZEND_EXTENSION_API_NO < PHP_5_3_X_API_NO
    zend_uint      early_binding;          /* the linked list of delayed declarations */
#endif

    void          *mem;                    /* shared memory area used by script structures */
    size_t         size;                   /* size of used shared memory */

    /* All entries that shouldn't be counted in the ADLER32
     * checksum must be declared in this struct
     */
    struct zend_persistent_script_dynamic_members {
        time_t       last_used;
        ulong        hits;
        unsigned int memory_consumption;
        unsigned int checksum;
        time_t       revalidate;
    } dynamic_members;
} zend_persistent_script;</code></pre>
<p>And here is how OPCache replaces the compiler structure by the <code>persistent_script</code> ones, simple function pointers switch :</p>
<pre><code>new_persistent_script = create_persistent_script();

/* Save the original values for the op_array, function table and class table */
orig_active_op_array = CG(active_op_array);
orig_function_table = CG(function_table);
orig_class_table = CG(class_table);
orig_user_error_handler = EG(user_error_handler);

/* Override them with ours */
CG(function_table) = &ZCG(function_table);
EG(class_table) = CG(class_table) = &new_persistent_script->class_table;
EG(user_error_handler) = NULL;

zend_try {
    orig_compiler_options = CG(compiler_options);
    /* Configure the compiler */
    CG(compiler_options) |= ZEND_COMPILE_HANDLE_OP_ARRAY;
    CG(compiler_options) |= ZEND_COMPILE_IGNORE_INTERNAL_CLASSES;
    CG(compiler_options) |= ZEND_COMPILE_DELAYED_BINDING;
    CG(compiler_options) |= ZEND_COMPILE_NO_CONSTANT_SUBSTITUTION;
    op_array = *op_array_p = accelerator_orig_compile_file(file_handle, type TSRMLS_CC); /* Trigger PHP compiler */
    CG(compiler_options) = orig_compiler_options;
} zend_catch {
    op_array = NULL;
    do_bailout = 1;
    CG(compiler_options) = orig_compiler_options;
} zend_end_try();

/* Restore originals */
CG(active_op_array) = orig_active_op_array;
CG(function_table) = orig_function_table;
EG(class_table) = CG(class_table) = orig_class_table;
EG(user_error_handler) = orig_user_error_handler;</code></pre>
<p>As we can see, the PHP compiler is fully isolated and disconnected from the tables it usually fills : it will now fill the <code>persistent_script</code> structures. Then OPCache will have to browse those structures, and replace request allocated pointers to shm ones. OPCache is interested in :</p>
<ul><li>The script functions</li>
<li>The script classes</li>
<li>The script main OPArray</li>
<li>The script path</li>
<li>The script structure itself</li>
</ul><p><img src="../../../img/opcache/opcache-shm-detailed.png" alt="opcache-shm-detailed"></p>
<p>The compiler is also told some options to disable some optimizations it does, like <code>ZEND_COMPILE_NO_CONSTANT_SUBSTITUTION</code> and <code>ZEND_COMPILE_DELAYED_BINDING</code>. That would add more work to OPCache. Remember that OPCache hooks into the Zend Engine, it is not a source code patch.</p>
<p>Now that we have a <code>persitent_script</code> structure, we must cache its informations. Remember that the PHP Compiler has filled-in our structures, but it allocated the memory behind this using the Zend Memory Manager : this memory will be freed at the end of the current request. We then need to browse this memory, and copy all of it into the shared memory segment, so that the informations we just gathered will now persist through several requests and won't need to be recomputed every time.</p>
<p>The process is as follow :</p>
<ul><li>Take the PHP script to cache, and compute every variable data size (every pointer target)</li>
<li>Reserve into already allocated shared memory one big block of this precise size</li>
<li>Iterate over the PHP script variable structures, and for each variable-data pointer target, copy it into the just-allocated shared memory block</li>
<li>Do the exact opposite for script loading, when this comes to play.</li>
</ul><p>So OPCache is clever about shared memory, and will not fragment it by freeing it and compacting it.
For every script, it computes the exact size this script needs to store informations into shared memory, and then copies the data into the segment. <strong>The memory is never freed nor given back to the OS by OPCache</strong> , thus the memory is perfectly aligned and never fragmented. This gives a big boost in performance of shared memory, as there is no linked-list or BTree to store and traverse when managing memory that can be freed (like malloc/free do). OPcache keeps storing things into the shared memory segment, and when the data become stale (because of script revalidation) : it does not free the buffers but mark them as "wasted". When the max wasted percentage is reached, OPCache triggers a restart. This model is very different from the old APC extension, for example, and has the big advantage of providing the same performances as time runs, because the memory buffer from SHM is never managed (freed, compacted, etc...), memory management operations are trully technically stuff which brings nothing to functionnalities, but performance penalty as they run. <strong>OPCache has been designed with highest possible performance in mind for the PHP environment runtime</strong>, not touching back the shared memory segment provides as well a very good rate of CPU caches hits (especially L1 and L2, as OPCache also aligns the memory pointers for them to better find a hit in an L1/L2 line).</p>
<p>Caching a script thus involves -as a first step- computing the exact size of its data. Here is the algorithm :</p>
<pre><code>uint zend_accel_script_persist_calc(zend_persistent_script *new_persistent_script, char *key, unsigned int key_length TSRMLS_DC)
{
    START_SIZE();

    ADD_SIZE(zend_hash_persist_calc(&new_persistent_script->function_table, (int (*)(void* TSRMLS_DC)) zend_persist_op_array_calc, sizeof(zend_op_array) TSRMLS_CC));
    ADD_SIZE(zend_accel_persist_class_table_calc(&new_persistent_script->class_table TSRMLS_CC));
    ADD_SIZE(zend_persist_op_array_calc(&new_persistent_script->main_op_array TSRMLS_CC));
    ADD_DUP_SIZE(key, key_length + 1);
    ADD_DUP_SIZE(new_persistent_script->full_path, new_persistent_script->full_path_len + 1);
    ADD_DUP_SIZE(new_persistent_script, sizeof(zend_persistent_script));

    RETURN_SIZE();
}</code></pre>
<p>I repeat : what we have to cache are :</p>
<ul><li>The script functions</li>
<li>The script classes</li>
<li>The script main OPArray</li>
<li>The script path</li>
<li>The script structure itself</li>
</ul><p>For functions, classes and OPArray, the iterating algorithm is deep searching : it caches every pointer data.
For example for the functions in PHP 5, we must copy into shared memory (shm) :</p>
<ul><li>The functions HashTable
<ol><li>The functions HashTable buckets table (Bucket **)</li>
<li>The functions HashTable buckets (Bucket *)</li>
<li>The functions HashTable buckets' key (char *)</li>
<li>The functions HashTable buckets' data pointer (void *)</li>
<li>The functions HashTable buckets' data (*)</li>
</ol></li>
<li>The functions OPArray
<ol><li>The OPArray filename (char *)</li>
<li>The OPArray literals (names (char <em>) and values (zval </em>))</li>
<li>The OPArray OPCodes (zend_op *)</li>
<li>The OPArray function name (char *)</li>
<li>The OPArray arg_infos (zend_arg_info <em>, and the name and class name as both char </em>)</li>
<li>The OPArray break-continue array (zend_brk_cont_element *)</li>
<li>The OPArray static variables (Full deep HashTable and zval *)</li>
<li>The OPArray doc comments (char *)</li>
<li>The OPArray try-catch array (zend_try_catch_element *)</li>
<li>The OPArray compiled variables (zend_compiled_variable *)</li>
</ol></li>
</ul><p>I did not detail all, and this changes for PHP 7 as the structures (such as the hashtable) are different.
The idea is as I expressed it : copy in shared memory every pointer data. As deep copies may involve recursive structures, OPCache uses a translate table for pointer storage : everytime it copies a pointer from regular request-bound memory to shared memory, it saves the association between the old pointer address, and the new pointer address.
The copy process, before copying, looks up this translate table to know if it has already copied the data, if so, it reuses the old pointer data so that it never duplicates any pointer data :</p>
<pre><code>void *_zend_shared_memdup(void *source, size_t size, zend_bool free_source TSRMLS_DC)
{
    void **old_p, *retval;

    if (zend_hash_index_find(&xlat_table, (ulong)source, (void **)&old_p) == SUCCESS) {
        /* we already duplicated this pointer */
        return *old_p;
    }
    retval = ZCG(mem);;
    ZCG(mem) = (void*)(((char*)ZCG(mem)) + ZEND_ALIGNED_SIZE(size));
    memcpy(retval, source, size);
    if (free_source) {
        interned_efree((char*)source);
    }
    zend_shared_alloc_register_xlat_entry(source, retval);
    return retval;
}</code></pre>
<p><code>ZCG(mem)</code> represents the fixed-size shared memory segment and is filled-in as elements are added. It then has already been allocated, there is no need to allocate memory on each copy (which would have been less performant), but simply fill-in the memory, and move forward the pointer address border.</p>
<p>We detailed the script caching algorithm, which role is to take any request-bound heap memory pointer and data and duplicate it into shared memory, if not already copied.
The loading algorithm does the exact opposite : it gets the <code>persistent_script</code> back from shared memory and browse every of its dynamic structures to duplicate every shared pointer to a request-bound allocated pointer.
The script is then ready to be run by the Zend Engine Executor, as it now doesn't embed any shared pointer address (which would lead to massive bugs of one script modifing the structure of its brother). The Zend Engine is tricked (hooked by OPCache) : it has seen nothing of the pointers replacement happening before the execution happens.</p>
<p>This process of copying from regular memory to shared memory (cache script), or the opposite (load script), is highly optimized, and even if it involves many memory copies or hash lookups, which are not really nice in term of performance, we are way faster than triggering the PHP compiler every time.</p>
<h3 id="sharing-interned-strings">Sharing interned strings<a href="#sharing-interned-strings" class="anchor">#</a></h3>
<p>Interned strings is a nice memory optimisation that's been added to PHP 5.4. This may feel like some comonsense : every time PHP meets an immutable string (a char*), it stores it into a special buffer and reuses the pointer for every occurence of this same string next to come. You may learn more about interned strings <a href="http://jpauli.github.io/2015/09/18/php-string-management.html#interned-strings">from this article</a>. Interned strings are about immutable strings, and thus are nearly exclusively used into the PHP compiler.</p>
<p>Interned strings work like this :</p>
<p><img src="../../../img/opcache/PHP-interned-strings.png" alt="PHP-interned-strings"></p>
<p>The same instance of a string is shared to every pointer. But there still is a problem with that : this interned string buffer is a per-process buffer, it is managed by the PHP compiler mainly. That means that in a PHP-FPM pool, every PHP worker will store its own copy of this buffer, something like this :</p>
<p><img src="../../../img/opcache/PHP-interned-strings-pools.png" alt="PHP-interned-strings-pools"></p>
<p>This leads to a massive waste of memory, especially in case you have tons of workers (you're likely to have), and you use very big strings in your PHP code (tip: PHP's annotation comments are strings). What OPCache takes care of, is sharing this buffer between every PHP worker of a pool. Something like this :</p>
<p><img src="../../../img/opcache/PHP-interned-strings-pools-shared.png" alt="PHP-interned-strings-pools-shared"></p>
<p>Et voila! OPCache shares the interned string buffers of all the PHP-FPM worker of the same pools, and uses its shm segment to store those.
Thus, you need to size the shm segment according to your interned strings usage as well. Also, OPCache allows you to tune the interned strings shm usage using <em>opcache.interned_strings_buffer</em> INI setting. Monitor OPCache and once more : make sure you have enough memory.
However here, if you run out of interned strings memory space (<em>opcache.interned_strings_buffer</em> setting is too low), OPCache will not trigger a restart, because it still has some shm available, only interned strings buffer is full, which is not blocking to continue processing request, you'll simply end up having some strings interned and shared, and some other that use PHP worker's memory. I don't recommand that for performance.</p>
<p>Read your logs, when you run out of interned string memory, OPCache warns you :</p>
<pre><code>if (ZCSG(interned_strings_top) + ZEND_MM_ALIGNED_SIZE(sizeof(Bucket) + nKeyLength) >=
        ZCSG(interned_strings_end)) {
        /* no memory, return the same non-interned string */
        zend_accel_error(ACCEL_LOG_WARNING, "Interned string buffer overflow");
        return arKey;
    }</code></pre>
<blockquote>
<p>Interned strings are about every piece of immutable string the PHP compiler is going to meet while doing its job : variable names, "php strings", function names, class names... PHP comments, nowadays used and called "annotations", are strings as well, and they are usually huge strings, that will eat most of your interned strings buffer. Think about them as well.</p>
</blockquote>
<h3 id="the-locking-mechanism">The locking mechanism<a href="#the-locking-mechanism" class="anchor">#</a></h3>
<p>As soon as we talk about shared memory (shm), we must talk about memory locking mecanisms.
The base line is simple : <strong>every PHP process that is willing to write into shared memory will lock every other process willing to write into shared memory as well</strong>. So the critical section is done on write operations, and not read operations. You may happen to have 150 PHP processes reading the shared memory, only one of them may write into the shm at the same time, write operation doesn't prevent read operation but another write operation.</p>
<p>So, <strong>there should be no dead-lock in OPCache, until you don't prime your cache smoothly</strong> . If, after your code deployment, you open your webserver to trafic, then there will be a massive rush on your scripts to compile and cache them, and as the cache write-to-shm operation is done under exclusive lock, you will probably lock every processes once the first lucky one has obtained a lock to write. When this latter will release the lock, every process waiting for it will then see that the file they just compiled is already stored into shm , and then they will trash the compilation result to load it from shm. This is a big waste of resources.</p>
<pre><code>/* exclusive lock */
zend_shared_alloc_lock(TSRMLS_C);

/* Check if we still need to put the file into the cache (may be it was
 * already stored by another process. This final check is done under
 * exclusive lock) */
bucket = zend_accel_hash_find_entry(&ZCSG(hash), new_persistent_script->full_path, new_persistent_script->full_path_len + 1);
if (bucket) {
    zend_persistent_script *existing_persistent_script = (zend_persistent_script *)bucket->data;

    if (!existing_persistent_script->corrupted) {
        if (!ZCG(accel_directives).revalidate_path &&
            (!ZCG(accel_directives).validate_timestamps ||
             (new_persistent_script->timestamp == existing_persistent_script->timestamp))) {
            zend_accel_add_key(key, key_length, bucket TSRMLS_CC);
        }
        zend_shared_alloc_unlock(TSRMLS_C);
        return new_persistent_script;
    }
}</code></pre>
<p>What you should do, is cut off your server from external webtraffic, deploy your new code, curl some of your most heavy URLs, so that your curl requests will smoothly prime the shm. When you think you are done with the big majority of your scripts, you may now open your webserver to traffic, so that now this one will massively read shm, which is a lock-free operation. Sure there may still be some little scripts not compiled yet, but as soon as they are uncommon, there is no pressure on the write lock.</p>
<p>What you should avoid, is writing PHP files at runtime, and then make use of them. For the exact same reason : as soon as you write a new PHP file onto your production server documentroot, and you make use of it, chances are that it will be rushed by thousands of PHP workers trying to compile and cache it into shm : you will lock.
Those dynamically generated PHP files should be added to the OPCache blacklist, using the <em>opcache.blacklist-filename</em> INI setting (which accepts glob patterns).</p>
<p>Technically speaking, the lock mecanism is not very strong, but it works on many flavors of Unix : it uses the famous <code>fcntl()</code> call</p>
<pre><code>void zend_shared_alloc_lock(TSRMLS_D)
{
    while (1) {
        if (fcntl(lock_file, F_SETLKW, &mem_write_lock) == -1) {
            if (errno == EINTR) {
                continue;
            }
            zend_accel_error(ACCEL_LOG_ERROR, "Cannot create lock - %s (%d)", strerror(errno), errno);
        }
        break;
    }
    ZCG(locked) = 1;
    zend_hash_init(&xlat_table, 100, NULL, NULL, 1);
}</code></pre>
<p>I here talked about memory locks happening on normal process : nothing bad, if you take care, no more than one PHP process should be writing to the shm at the same time, so you won't suffer from any lock waiting times.</p>
<p>There exists however another lock that you should prevent from happening : the memory exhausted lock. This is the next chapter</p>
<h3 id="understanding-the-opcache-memory-consumption">Understanding the OPCache memory consumption<a href="#understanding-the-opcache-memory-consumption" class="anchor">#</a></h3>
<p>So I remind you with facts :</p>
<ul><li>OPCache creates one unique segment of shared memory, once for all, at PHP startup (when you start PHP-FPM)</li>
<li>OPCache never frees some shm into this segment, the segment is allocated at startup, then filled-in according to the needs</li>
<li>OPCache locks shm when it writes into it</li>
<li>shm is used for several purposes :
<ol><li>Script's datastructure caching, involving obviously OPCodes caching but not only</li>
<li>Shared interned strings buffer</li>
<li>Cached scripts HashTable</li>
<li>Global OPCache shared memory state</li>
</ol></li>
</ul><p>If you use validation of your scripts, OPCache will check their modification date at every access (not every, check <em>opcache.revalidate_freq</em> INI setting), and will have a hint of wheither the file is fresh or stale. This check is cached : it is <strong>not</strong> costly as opposed to what you could think. OPCache comes into the scene some time after PHP, and PHP has already <code>stat()</code>ed the file : OPCache just reuses this information and does not issue a costly <code>stat()</code> call to the filesystem again for its own use.</p>
<p>If you use timestamp validation, via <em>opcache.validate_timestamps</em> and <em>opcache.revalidate_freq</em>, and your file has effectively changed, then OPCache will simply invalidate it, and flag all of its shm data as invalid. It will not free anything from shm. OPCache flags the shm parts as "wasted". <strong>Only when OPCache runs out of shm on an allocation AND when wasted memory reaches the <em>opcache.max_wasted_percentage</em> INI setting value, OPCache will trigger a full restart, which is something you must absolutely prevent from happening</strong> No other scenario.</p>
<pre><code>/* Calculate the required memory size */
memory_used = zend_accel_script_persist_calc(new_persistent_script, key, key_length TSRMLS_CC);

/* Allocate shared memory */
ZCG(mem) = zend_shared_alloc(memory_used);
if (!ZCG(mem)) {
    zend_accel_schedule_restart_if_necessary(ACCEL_RESTART_OOM TSRMLS_CC);
    zend_shared_alloc_unlock(TSRMLS_C);
    return new_persistent_script;
}</code></pre>
<p><img src="../../../img/opcache/opcache-wasted-shm.png" alt="opcache-wasted-shm"></p>
<p>The picture above details what your shm segment could look like after some time has passed and some scripts have changed. The changed scripts' memory has been marked as "wasted", and OPCache will simply now ignore those memory areas, as well as it will recompile your changed scripts and create a new memory segment for their informations.</p>
<p>When enough wasted memory is reached, a restart will happen, OPCache will then lock shm, reset the shm segment (empty it entirely), and release the lock. This will let your server in a situation like if it has just started : every PHP worker is going to stress the lock now, because every worker will try to compile some files : your web server will now suffer from a very poor performance because of locks. The more the load, the less performance, this is unfortunately the rule with locks. So your server may really suffer for long seconds now.</p>
<blockquote>
<p><strong>Never run out of shared memory</strong></p>
</blockquote>
<p>More generally, what you should do is disable script modification tracking on production server, that way you are sure the cache will never trigger a restart (this is not entirely true as OPCache may still run out of persistent script key space, we'll see that later). A classic deployment should follow the rules :</p>
<ul><li>take out the server from load (disconnect it from your load balancer)</li>
<li>empty opcache (call <code>opcache_reset()</code>) or directly shut down FPM (better, we'll detail in few minutes)</li>
<li>deploy a new version of your application at once</li>
<li>restart your FPM pool if needed and prime your new cache smoothly by triggering curl request on major application entry points</li>
<li>open back your server to traffic</li>
</ul><p>All this can be done with a 50 line shell script that can be turned very robust playing with <code>lsof</code> and <code>kill</code> in case some hard requests don't seem to finish. Bring your Unix knowledge ;-) </p>
<p>You can even see what happens using one of the numerous GUI frontends for OPCache available anywhere on the web and Github, they all make use of the <code>opcache_get_status()</code> function:</p>
<p><img src="../../../img/opcache/opcache-frontend.png" alt="opcache-frontend"></p>
<p>This is not the full story though, there is another thing to clearly keep in mind : <strong>cache keys</strong>.</p>
<p>When OPCache stores a cached script into SHM, it stores its into a HashTable, to be able to find the script back after. But it has to choose a key to index the HashTable. What index/key does OPCache use to achieve this goal ? This highly depends on both the configuration, and the way your app has been designed.</p>
<p>Normally, OPCache resolves the full path to the script, but take care as it uses <a href="http://jpauli.github.io/2014/06/30/realpath-cache.html">the PHP's realpath cache</a> and you may suffer from it. If you change your documentroot using a symlink, put <em>opcache.revalidate_path</em> to 1 and empty your realpath cache (which may be hard to do as it is bound to the PHP worker process handling the current request).</p>
<p>So OPCache resolves the path to the file, and when resolved, <strong>it uses the realpath string as cache key for the script</strong>, and that's all, assuming you have  <em>opcache.revalidate_path</em> INI setting turned to 1. If not, OPCache will also use the <strong>unresolved path</strong> as a cache key, and that will lead to problems if you were using symlinks, because if you then change the symlink target, OPCache will not notice it, as it will still use the unresolved path as key to find the old targetted script (this is to save a symlink resolution call).</p>
<p>By turning <em>opcache.use_cwd</em> to 1, you tell OPCache to prepend the <code>cwd</code> to every key, in case you use <em>relative paths</em> to include your files, like <code>require_once "./foo.php";</code>. I suggest, if you use relative paths and host several applications on the same PHP instance (which you shouldn't do), to always put <em>opcache.use_cwd</em> to 1. Also, if you happen to play with symlinks, turn <em>opcache.revalidate_path</em> to 1. But even with those settings on, you will suffer from <a href="http://jpauli.github.io/2014/06/30/realpath-cache.html">PHP's realpath cache</a>, and you may change the <em>www</em> symlink to another target, it won't be noticed by OPCache, even if you empty the cache by using <code>opcache_reset()</code>.</p>
<blockquote>
<p>Because of PHP's realpath cache, you may experience problems if using symlinks to handle your documentroot for deployment. Turn <em>opcache.use_cwd</em> and <em>opcache.revalidate_path</em> to 1, but even with those settings, bad symlink resolutions may happen, this is because PHP answers OPCache realpath resolution requests with a wrong answer, comming from its realpath_cache mechanism.</p>
</blockquote>
<p>If you want to be extra safe in your deployment, the first option is to not use symlinks to manage your documentroot.
If not, then use a double FPM pool, and use a FastCGI load balancer to balance between the two pools when deploying. Lighttpd and Nginx have this feature enabled by default as far as I remember :</p>
<ul><li>take out the server from load (disconnect it from your load balancer)</li>
<li>shut down FPM, you will kill PHP (and then OPCache) and will be extra safe especially about PHP's realpath cache, which may trick you. This latter will be cleared if you shut down FPM. Monitor the eventual workers that may be stuck, and kill them if necessary.</li>
<li>deploy a new version of your application at once</li>
<li>restart your FPM pool. Don't forget to prime your new cache smoothly by triggering curl requests on major application entry points before</li>
<li>open back your server to traffic</li>
</ul><p>If you don't want to take your server out of the balancer, what can be done then, is :</p>
<ul><li>Deploy your new code into another directory, as your PHP server has one FPM pool still active and serving production requests</li>
<li>Start another FPM pool, listening on another port, while still having the first FPM pool active and serving production requests</li>
<li>Now you have two FPM pools, one hot and working, one idle, waiting to be bound to requests</li>
<li>Change your documentroot symlink target to target the new deploy path, and immediately after, stop the first FPM pool. If you told your webserver about your two pools, it should notice the first pool is dying, and should load balance traffic to the new pool now, with no traffic interruption nor failing requests. The second pool will then be triggered, will resolve the new docroot symlink (as it is fresh and has a cleared realpath cache), and serve your new content. This clearly works, I used that on production servers many times, a ~80 lines well written shell script can take care of all this job.</li>
</ul><p>So depending on the settings, one unique script may lead to several keys computed by opcache. But the key store is not infinite : it is also allocated into shared memory, and may get full, in which case even if there is still lot of room into the shm, because the persistent script hashtable is full, OPCache will behave like if it had no more memory, and will trigger a restart for next requests. </p>
<blockquote>
<p>You always should monitor the number of keys in the key store, for it never to be full.</p>
</blockquote>
<p>OPCache gives you this information with the use of <code>opcache_get_status()</code>, a function the different GUIs rely on. The <em>num_cached_keys</em> dimension returned by this function gives the info. You should preconfigure the number of keys, as a hint, using <em>opcache.max_accelerated_files</em> INI setting. Take care as the name suggests a number of files, in fact it is the number of keys that OPCache will compute, and as we've seen, one file may lead to several keys beeing computed. Monitor it, and use the right number. Avoid using relative paths in require_once statements, it makes OPCache generate more keys. Using an autoloader is recommanded, as this one, if well configured, will always issue include_once calls with full paths, and not relative ones.</p>
<blockquote>
<p>OPCache preallocates the HashTable to store future persistent scripts when it starts (when PHP starts), and never tries to resize it. If it gets full, it will then trigger a restart. This is done for performance reasons.</p>
</blockquote>
<p>So this is why you may see a <em>num_cached_scripts</em> dimension which is different from the <em>num_cached_keys</em> dimension, from OPcache status report. Only the <em>num_cached_keys</em> info is relevant, if it reaches <em>max_cached_keys</em>, you'll be in trouble with a restart pending.</p>
<p>Do not forget that you can understand what happens by lowering OPCache's log level (<em>opcache.log_verbosity_level</em> INI). It tells you if it runs out of memory, and which kind of OOM (OutOfMemory) error it generated : if it is related to the shm beeing full, or if it is the keys Hashtable which is full.</p>
<p><img src="../../../img/opcache/opcache-log.png" alt="opcache-log"></p>
<pre><code>static void zend_accel_add_key(char *key, unsigned int key_length, zend_accel_hash_entry *bucket TSRMLS_DC)
{
    if (!zend_accel_hash_find(&ZCSG(hash), key, key_length + 1)) {
        if (zend_accel_hash_is_full(&ZCSG(hash))) {
            zend_accel_error(ACCEL_LOG_DEBUG, "No more entries in hash table!");
            ZSMMG(memory_exhausted) = 1;
            zend_accel_schedule_restart_if_necessary(ACCEL_RESTART_HASH TSRMLS_CC);
        } else {
            char *new_key = zend_shared_alloc(key_length + 1);
            if (new_key) {
                memcpy(new_key, key, key_length + 1);
                if (zend_accel_hash_update(&ZCSG(hash), new_key, key_length + 1, 1, bucket)) {
                    zend_accel_error(ACCEL_LOG_INFO, "Added key '%s'", new_key);
                }
            } else {
                zend_accel_schedule_restart_if_necessary(ACCEL_RESTART_OOM TSRMLS_CC);
            }
        }
    }
}</code></pre>
<p>So, to conclude about memory usage, here is the picture :</p>
<p><img src="../../../img/opcache/OPCache-memory-structure.png" alt="OPCache-memory-structure"></p>
<p>When you start PHP, you start OPCache, it allocates immediately <em>opcache.memory_consumption</em> Megabytes of shared memory (shm) from the OS.
It then starts using this space, and stores into it the interned strings buffer (<em>opcache.interned_strings_buffer</em>). After that, it preallocates the HashTable for future persistent scripts and their keys to be stored. The space used depends on the <em>opcache.max_accelerated_files</em>.</p>
<p>Now, a part of the shm is used by OPCache internals, and the non-occupied space left is dedicated to you : to your scripts datastructures. This (actually free) memory segment will then be filled in, and as your scripts will change and OPCache will recompile them (assuming you told it to), the space will slowly become "wasted"; except if you tell OPCache not to recompile changed scripts (recommanded).</p>
<p>That may look like something like that :</p>
<p><img src="../../../img/opcache/OPCache-memory-structure-hot.png" alt="OPCache-memory-structure-hot"></p>
<p>If persistent scripts HashTable becomes full, or if free SHM runs out : OPCache will trigger a restart (which you'd want to prevent absolutely).</p>
<h3 id="configuring-opcache">Configuring OPCache<a href="#configuring-opcache" class="anchor">#</a></h3>
<p>If you use a framework based application, like a Symfony based application, I strongly suggest :</p>
<ul><li>you turn off revalidation mechanism on production (turn <em>opcache.validate_timestamps</em> to 0)</li>
<li>you deploy using a full new runtime of your scripts, this is the case with Symfony applications</li>
<li>you size correctly your buffers
<ol><li><em>opcache.memory_consumption</em>, the most important</li>
<li><em>opcache.interned_strings_buffer</em> , monitor your usage, and size accordingly, take care if you tell OPCache to save comments, which you will likely do if you use PHP "annotations" (<em>opcache.save_comments = 1</em>), those are strings, big strings, that will eat your interned strings buffer</li>
<li><em>opcache.max_accelerated_files</em> , numbers of keys to preallocate, once more : monitor and size accordingly</li>
</ol></li>
<li>You turn off <em>opcache.opcache.revalidate_path</em> and <em>opcache.use_cwd</em>. That will save some key space</li>
<li>You turn on <em>opcache.enable_file_override</em> , this will accelerate the autoloader</li>
<li>You fill-in <em>opcache.blacklist_filename</em> list with the script names you are likely to generate during runtime; shouldn't be too many of them anyway</li>
<li>You turn off <em>opcache.consistency_checks</em>, this basically checks a control sum on your scripts, that eats perf</li>
</ul><p>With those settings, your memory should never get wasted, then <em>opcache.max_wasted_percentage</em> is not very useful in this case.
With those settings, you'll need to turn off your main FPM instance when deploying. You may play with several FPM pools to prevent service downtime, like explained earlier.</p>
<p>That should be enough.</p>
<h3 id="opcache-compiler-s-optimizer">OPCache compiler's optimizer<a href="#opcache-compiler-s-optimizer" class="anchor">#</a></h3>
<h4 id="introducing">Introducing<a href="#introducing" class="anchor">#</a></h4>
<p>So we talked about caching OPCodes into shm and loading them back later. Just before caching them, OPCache may also run optimizer passes.
To fully understand the optimizer, you have to have a good knowledge of <a href="http://jpauli.github.io/2015/02/05/zend-vm-executor.html">how the Zend VM Executor works</a>. Also, you may bring your compiler knowledge, if you are very new to such concepts, perhaps starting <a href="https://msdn.microsoft.com/en-us/magazine/dn904673.aspx">reading some articles on the subject</a> may help ? Or at least the mandatory-reading <a href="http://en.wikipedia.org/wiki/Compilers:_Principles,_Techniques,_and_Tools">Dragon Book</a> ? Anyway I'll try to make the subject understandable and fun to read.</p>
<p>Basically, the optimizer is given the whole OPArray structure, and may now browse it, find flaws, and fix them. But as we are analyzing OPCodes <strong>at compile time</strong>, we have no clue at all on everything tied to a "PHP variable". Basically, we don't know yet what will be stored in any <em>IS_VAR</em> or <em>IS_CV</em> operand, but only in <em>IS_CONST</em> or sometimes in <em>IS_TMP_VAR</em>.
Like in any compiler for every languages : we must create the most optimized structure to be run at runtime, so that the runtime will be the fastest as possible.</p>
<p>OPCache optimizer can optimize a lot of things in <em>IS_CONST</em>; We can also replace some OPCodes by others (more optimized at runtime), we also find and trash dead code branches by using a CFG (control flow graph) analysis, but we don't unroll loops, or process to loop invariant motions as such optimizations are hard to apply to PHP.
We also have other possibilities related to PHP internals : we may change the way classes are bound to optimize a bit the process in some specific cases, but we have absolutely not the possibility to do some cross file optimizations, because OPCache plays with OPArrays coming from file compilation (among other functions' OPArrays), and there is a total isolation of those OPArrays. PHP has never been built on a cross file based VM : the Virtual Machine and the language is file bound : when compiling a file, we have absolutely no information about the files that already got compiled, and those to come next.
We then must try to optimize on a file-by-file basis, and must not assume for example that class A will be present in the future, if it is not at the moment. This is very different from Java or C++ that compile using compilation units and allowing cross-file optimizations; PHP simply won't do that, it's not been designed like that.</p>
<blockquote>
<p>The PHP compiler acts on a file basis and has no shared state through file compilations, it doesn't compile a project in its whole, but a file, followed by others.
There is no room for cross file optimizations.</p>
</blockquote>
<p>OPCache optimization passes can be enabled on a case-by-case basis, using the INI setting <em>opcache.optimization_level</em>. It should represent a mask for optimizations you'd like to see enabled, based on their binary values :</p>
<pre><code>/* zend_optimizer.h */
#define ZEND_OPTIMIZER_PASS_1       (1<<0)   /* CSE, STRING construction     */
#define ZEND_OPTIMIZER_PASS_2       (1<<1)   /* Constant conversion and jumps */
#define ZEND_OPTIMIZER_PASS_3       (1<<2)   /* ++, +=, series of jumps      */
#define ZEND_OPTIMIZER_PASS_4       (1<<3)   /* INIT_FCALL_BY_NAME -> DO_FCALL */
#define ZEND_OPTIMIZER_PASS_5       (1<<4)   /* CFG based optimization       */
#define ZEND_OPTIMIZER_PASS_6       (1<<5)
#define ZEND_OPTIMIZER_PASS_7       (1<<6)
#define ZEND_OPTIMIZER_PASS_8       (1<<7)   
#define ZEND_OPTIMIZER_PASS_9       (1<<8)   /* TMP VAR usage                */
#define ZEND_OPTIMIZER_PASS_10      (1<<9)   /* NOP removal                 */
#define ZEND_OPTIMIZER_PASS_11      (1<<10)  /* Merge equal constants       */
#define ZEND_OPTIMIZER_PASS_12      (1<<11)  /* Adjust used stack           */
#define ZEND_OPTIMIZER_PASS_13      (1<<12)
#define ZEND_OPTIMIZER_PASS_14      (1<<13)
#define ZEND_OPTIMIZER_PASS_15      (1<<14)  /* Collect constants */

#define ZEND_OPTIMIZER_ALL_PASSES   0xFFFFFFFF

#define DEFAULT_OPTIMIZATION_LEVEL  "0xFFFFBFFF"</code></pre>
<h4 id="known-constant-statements-and-branch-trashing">Known constant statements and branch trashing<a href="#known-constant-statements-and-branch-trashing" class="anchor">#</a></h4>
<p>Note that many compile-time known constant statements are NOT computed by the compiler but by OPCache, for PHP 5.
In PHP 7, those are computed in the compiler.</p>
<p>Here we go with examples :</p>
<pre><code>if (false) {
    echo "foo";
} else {
   echo "bar";
}</code></pre>
<p>This leads in classical compilation to :</p>
<p><img src="../../../img/opcache/optimizer/1.png" alt="OPCache-optimizer-1"></p>
<p>And optimized compilation :</p>
<p><img src="../../../img/opcache/optimizer/1-opt.png" alt="OPCache-optimizer-1-opt"></p>
<p>As we can see, the dead code in the <code>if(false)</code> branch has been trashed, the Zend VM executor will then simply have to run a <code>ZEND_ECHO</code> OPcode. We then saved some memory, because we threw away some OPCodes, and we may save a little bit of CPU cycles at runtime as well.</p>
<p>I recall you that we cannot know the content of any variable yet, as we are still at compile time (we are between compilation and execution). A code with an <em>IS_CV</em> operand instead of <em>IS_CONST</em>, could not have been optimized :</p>
<pre><code>/* That cant be optimized, what's in $a ? */
if ($a) {
    echo "foo";
} else {
   echo "bar";
}</code></pre>
<p>Let's take another example so that you see the differences between PHP 5 and PHP 7 :</p>
<pre><code>if (__DIR__ == '/tmp') {
    echo "foo";
} else {
   echo "bar";
}</code></pre>
<p>In PHP 7, the constant <code>__DIR__</code> will be substituted and the equality check will be performed by the PHP 7 compiler, that is without OPCache. However, the branch analysis and the branch dead code removing is still done by an OPCache optimizer pass.
In PHP 5 however, the constant <code>__DIR__</code> is still substituted, but the equality check is not performed by PHP 5 compiler. This latter is performed by OPCache.</p>
<p>So here to sum up things, if you run both PHP 5 and PHP 7 with OPCache optimizer activated, you will end up to the exact same optimized OPCodes. But if you don't run OPCache optimizer, then the PHP 5 compiled code will be less efficient than the equivalent PHP 7 one, because the PHP 5 compiler doesn't perform any evaluation, whereas PHP 7 compiler computes a lot of things by itself (without the need of OPCache optimizer that would come later).</p>
<h4 id="constant-functions-pre-evaluation">Constant functions pre-evaluation<a href="#constant-functions-pre-evaluation" class="anchor">#</a></h4>
<p>However, OPCache is able to turn some <em>IS_TMP_VAR</em> to <em>IS_CONST</em>. That is, OPCache can compute itself at compile time, some known values.
Some functions can be run at compile time, because their result will be constant. This is the case of several of them :</p>
<ul><li><code>function_exists()</code> and <code>is_callable()</code>, for internal functions only</li>
<li><code>extension_loaded()</code>, if <code>dl()</code> is disabled in userland</li>
<li><code>defined()</code> and <code>constant()</code> for internal constants only</li>
<li><code>dirname()</code> if the argument is constant</li>
<li><code>strlen()</code> and <code>dirname()</code> with constant argument (PHP 7 only)</li>
</ul><p>So look at that example :</p>
<pre><code>if (function_exists('array_merge')) {
    echo 'yes';
}</code></pre>
<p>Here, if the optimizer is diabled, the compiler generates many work to do for the runtime :</p>
<p><img src="../../../img/opcache/optimizer/7.png" alt="OPCache-optimizer-7"></p>
<p>Optimized as :</p>
<p><img src="../../../img/opcache/optimizer/7-opt.png" alt="OPCache-optimizer-7-opt"></p>
<p>Notice that those functions don't compute userland-based. For example :</p>
<pre><code>if function_exists('my_custom_function')) { }</code></pre>
<p>is not optimized, because you are very likely to have (or not) defined the 'my_custom_function' is another file. And remember, the PHP compiler and OPCache optimizer only works on a file basis. Even if you do that :</p>
<pre><code>function my_custom_function() { }
if function_exists('my_custom_function')) { }</code></pre>
<p>That will not be optimized, because this is too unlikely to happen, the function call optimizer only works for <em>internal</em> types (internal functions, internal constants).</p>
<p>Another example with <code>dirname()</code> (PHP 7 only) :</p>
<pre><code>if (dirname(__FILE__) == '/tmp') {
    echo 'yo';
}</code></pre>
<p>Not optimized :</p>
<p><img src="../../../img/opcache/optimizer/8.png" alt="OPCache-optimizer-8"></p>
<p>Optimized :</p>
<p><img src="../../../img/opcache/optimizer/7-opt.png" alt="OPCache-optimizer-8-opt"></p>
<p>Again, <code>strlen()</code> is optimized in PHP 7. If we chain them together, we obviously meet a nice optimization. Like this :</p>
<pre><code>if (strlen(dirname(__FILE__)) == 4) {
    echo "yes";
} else {
    echo "no";
}</code></pre>
<p>Not optimized :</p>
<p><img src="../../../img/opcache/optimizer/10.png" alt="OPCache-optimizer-10"></p>
<p>Optimized :</p>
<p><img src="../../../img/opcache/optimizer/10-opt.png" alt="OPCache-optimizer-10-opt"></p>
<p>For the example above, you can notice that every statement have been computed at compile/optimization time, and then OPCache optimizer trashed all the 'false' branch (assuming obviously that the 'true' part was chosen).</p>
<h4 id="transtyping">Transtyping<a href="#transtyping" class="anchor">#</a></h4>
<p>OPCache optimizer may switch your <em>IS_CONST</em> operand types, when it knows runtime will have to transtype them. That effectively saves some CPU cycles at runtime :</p>
<pre><code>$a = 8;
$c = $a + "42";
echo $c;</code></pre>
<p>Classical compilation :</p>
<p><img src="../../../img/opcache/optimizer/2.png" alt="OPCache-optimizer-2"></p>
<p>Optimized compilation :</p>
<p><img src="../../../img/opcache/optimizer/2-opt.png" alt="OPCache-optimizer-2-opt"></p>
<p>Look at the second operand true type of <code>ZEND_ADD</code> operation : it has switched from a string to an int. The optimizer did the job of transtyping the argument type for the math add operation. If it had not : the runtime VM would have done it again, and again, and again as the code is run again, and again, and again. This saves some CPU cycles involved in the transtyping operation.</p>
<p>Here is the OPCache optimizer code that does such a job :</p>
<pre><code>if (ZEND_OPTIMIZER_PASS_2 & OPTIMIZATION_LEVEL) {
    zend_op *opline;
    zend_op *end = op_array->opcodes + op_array->last;

    opline = op_array->opcodes;
    while (opline < end) {
        switch (opline->opcode) {
            case ZEND_ADD:
            case ZEND_SUB:
            case ZEND_MUL:
            case ZEND_DIV:
                if (ZEND_OP1_TYPE(opline) == IS_CONST) {
                    if (ZEND_OP1_LITERAL(opline).type == IS_STRING) {
                        convert_scalar_to_number(&ZEND_OP1_LITERAL(opline) TSRMLS_CC);
                    }
                }
                /* break missing *intentionally* - the assign_op's may only optimize op2 */
            case ZEND_ASSIGN_ADD:
            case ZEND_ASSIGN_SUB:
            case ZEND_ASSIGN_MUL:
            case ZEND_ASSIGN_DIV:
                if (opline->extended_value != 0) {
                    /* object tristate op - don't attempt to optimize it! */
                    break;
                }
                if (ZEND_OP2_TYPE(opline) == IS_CONST) {
                    if (ZEND_OP2_LITERAL(opline).type == IS_STRING) {
                        convert_scalar_to_number(&ZEND_OP2_LITERAL(opline) TSRMLS_CC);
                    }
                }
                break;
    /* ... ... */</code></pre>
<p>You should note however, that such optimization has been merged into the PHP 7 compiler. That means that even with OPCache disabled (or optimizations disabled), PHP 7 compiler already performs such an optimization, as well as many more that were not performed by the PHP 5 compiler.      </p>
<p>A little bit more silly, but adding two <em>IS_CONST</em> expressions, the result can then be computed at compile time, something the PHP compiler does not do by default in PHP 5, OPCache optimizer is needed :</p>
<pre><code>$a = 4 + "33";
echo $a;</code></pre>
<p>Classical compilation :</p>
<p><img src="../../../img/opcache/optimizer/3.png" alt="OPCache-optimizer-3"></p>
<p>Optimized compilation :</p>
<p><img src="../../../img/opcache/optimizer/3-opt.png" alt="OPCache-optimizer-3-opt"></p>
<p>The optimizer computed the maths for <code>4 + 33</code>, and erased the <code>ZEND_ADD</code> operation to be run by replacing it directly by the result. This saves again some CPU at runtime, as the VM executor now has less job to do. Here again, this is done in PHP 7 by the compiler, whereas in PHP 5 you would need OPCache optimizer to do that.</p>
<h4 id="optimized-opcodes-substitution">Optimized OPCodes substitution<a href="#optimized-opcodes-substitution" class="anchor">#</a></h4>
<p>Now let's dive deeper into OPCodes. Sometimes (rarely), it is possible to substitue a following of OPCodes by other ones, more optimized. Look at that :</p>
<pre><code>$i = "foo";
$i = $i + 42;
echo $i;</code></pre>
<p>Classical compilation :</p>
<p><img src="../../../img/opcache/optimizer/4.png" alt="OPCache-optimizer-4"></p>
<p>Optimized compilation :</p>
<p><img src="../../../img/opcache/optimizer/4-opt.png" alt="OPCache-optimizer-4-opt"></p>
<p>Here, our knowledge of the Zend VM executor leads us to substitue a <code>ZEND_ADD</code> plus a <code>ZEND_ASSIGN</code>, into a <code>ZEND_ASSIGN_ADD</code>, usually involved in statements such as <code>$i+=3;</code>
<code>ZEND_ASSIGN_ADD</code> is more optimized, it is one OPCode instead of two (which usually is better, but not every time)</p>
<p>On the same subject :</p>
<pre><code>$j = 4;
$j++;
echo $j;</code></pre>
<p>Classical compilation :</p>
<p><img src="../../../img/opcache/optimizer/5.png" alt="OPCache-optimizer-5"></p>
<p>Optimized compilation :</p>
<p><img src="../../../img/opcache/optimizer/5-opt.png" alt="OPCache-optimizer-5-opt"></p>
<p>Here, OPCache optimizer replaced the <code>$i++</code> by a <code>++$i</code> statement, because it had the same meaning in this piece of code. <code>ZEND_POST_INC</code> is not very nice OPCode, because it must read the value, return it as-is, but increment a temporary value in memory, whereas <code>ZEND_PRE_INC</code> plays with the value itself, and reads it, increments it and returns it (this is just the PRE vs POST incrementation difference).
Because the intermediate value returned by <code>ZEND_POST_INC</code> is not used in the script above, the compiler must issue a <code>ZEND_FREE</code> OPCode, to free it from memory. OPCache optimizer turns the structure into a <code>ZEND_PRE_INC</code>, and removes the useless <code>ZEND_FREE</code> : less job to figure out at runtime.</p>
<h4 id="constant-substitution-and-precomputing">Constant substitution and precomputing<a href="#constant-substitution-and-precomputing" class="anchor">#</a></h4>
<p>What about PHP constants ? They are more complex that what you think (much more in fact). So some optimizations that may seems obvious actually don't happen for many reasons, but let's see the actual ones :</p>
<pre><code>const FOO = "bar";
echo FOO;</code></pre>
<p><img src="../../../img/opcache/optimizer/6.png" alt="OPCache-optimizer-6"></p>
<p>Optimized compilation :</p>
<p><img src="../../../img/opcache/optimizer/6-opt.png" alt="OPCache-optimizer-6-opt"></p>
<p>This is part of temporary variables optimizations, as we can see, here, once again, one OPCode have been trashed, the result of constant reading is directly figured out at compile time, into the optimizer, and the runtime will have less work to do.</p>
<p>Also, that ugly <code>define()</code> function can be replaced by a <code>const</code> statement, if its argument is constant :</p>
<pre><code>define('FOO', 'bar');
echo FOO;</code></pre>
<p>The non optimized OPCodes from this little script are horrible in term of performance :</p>
<p><img src="../../../img/opcache/optimizer/9.png" alt="OPCache-optimizer-9"></p>
<p>Optimized, is as expected :</p>
<p><img src="../../../img/opcache/optimizer/6-opt.png" alt="OPCache-optimizer-9-opt"></p>
<p><code>define()</code> is ugly, because it declares a constant but runs such a job at runtime, issuing a function call (<code>define()</code> is really a function). This is very bad.
The <code>const</code> keyword leads to a <code>DECLARE_CONST</code> OPCode. <a href="http://jpauli.github.io/2015/02/05/zend-vm-executor.html#define-and-const">More on that in my ZendVM article</a>. Note that in PHP 7, <code>define()</code> may lead to a const construct into the compiler directly (no optimizer needed).</p>
<h4 id="multiple-jump-target-resolution">Multiple jump target resolution<a href="#multiple-jump-target-resolution" class="anchor">#</a></h4>
<p>This is actually a little bit hard to detail, but as usual with a simple example, you'll understand.
This optimization is about jump targets in jump opcodes (there are several flavors of them). Everytime the VM must jump, a jump address is computed by the compiler and stored into the VM operand. A jump is the result of a decision when the VM meets a decision point.
There are lots of jumps into PHP scripts. <code>if</code>, <code>switch</code>, <code>while</code>, <code>try</code>, <code>foreach</code>, <code>?:</code>  ... are PHP statements making decision, if the decision is true : jump to branch A, if not, jump to branch B.</p>
<p>Such algorithms can be optimized if the jump target is itself a jump. The landing jump will then make the VM jump again, to a final landing jump.
Multiple jump target resolution is about directly making the VM jump to the final target.</p>
<p>Something like that :</p>
<pre><code>if ($a) {
    goto a;
} else {
    echo "no";
}

a:
echo "a";</code></pre>
<p>With classical compilation, we end up with such OPCodes :</p>
<p><img src="../../../img/opcache/optimizer/11.png" alt="OPCache-optimizer-11"></p>
<p>Translated (just read it) as : "if the result of $a evaluation is zero, jump to target 3, in target 3 echo "no". If not, continue, and meet a jump to 4. In 4, echo "a".</p>
<p>This is something like "Jump to 3, and in 3, jump to 4". Why not "jump to 4" directly then ?
This is what the optimization does :</p>
<p><img src="../../../img/opcache/optimizer/11-opt.png" alt="OPCache-optimizer-11-opt"></p>
<p>Here, we can translate that by "if $a evaluation is not zero, jump to 2 which echoes "a", if not, echo "no".  Much simpler isn't it ?
This optimization shows true power in case of very complex scripts with many levels of decisions. Like having a <code>while</code> into an <code>if</code>, in which a <code>goto</code> is performed, leading to a <code>switch</code> which performs <code>try-catches</code> , etc...
Without this optimization, the overall OPArray may contain tons of OPCodes. Those will mainly be jumps, but probably jumps leading to jumps. Activating this optimization can sometimes (depend on the script) reduce significantely the number of OPCodes and ease the path the VM will branch ; leading in little gain of performances at runtime.</p>
<h4 id="concluding">Concluding<a href="#concluding" class="anchor">#</a></h4>
<p>I did not show you all the work done by the optimizer. It can also optimize embeded loops by issuing "early returns" for example. Same for embed try catch blocks or switch-breaks. PHP function calls, which is a heavy process into the engine, is also optimized when possible.</p>
<blockquote>
<p>The main difficulty in optimizer passes, is to never change the meaning of the script, and especially its control flow.</p>
</blockquote>
<p>The main difficulty in optimizer passes, is to never change the meaning of the script, and especially its control flow. Bugs were found about this some time ago in OPCache, and it is all but cool when you come to see that PHP executor doesn't behave the way it should, having your little PHP script written under your eyes... In fact, the OPCodes generated have been altered by the optimizer and the engine just runs something which is wrong. Not cool.</p>
<p>Nowadays, OPCache optimizer is pretty stable but still under developpment for next PHP versions. It had to be patched in deep for PHP 7 as that latter changed many things in internal structures design, as well as having a PHP 7 compiler doing much more optimization job (the most trivial however) than PHP 5 used to do (PHP 5 compiler really does not optimize anything).</p>
<blockquote>
<p>The PHP 7 compiler is much more efficient that PHP 5's. A lot of optimizations before performed in PHP 5 OPCache are now embeded directly into PHP 7's heart.</p>
</blockquote>
<h3 id="end">End<a href="#end" class="anchor">#</a></h3>
<p>We've seen that OPCache has finally become the standard recommanded PHP OPCode caching solution. We detailed how it works, not that hard to understand, but error prone yet. Nowadays, OPCache is very mature/stable and achieves its goal of boosting dramatically the overall performance of the PHP language by both canceling the time needed to compile a script and by optimizing the OPCodes resulting of the compilation. Shared memory is used for every process of a PHP pool to be able to access structures that have been added by others. Interned strings buffer is also managed in shared memory, leading to even more memory savings in a PHP pool of workers - typically using PHP-FPM SAPI.</p>
    </div>

      </article>
          </div>
        
                          <footer>
            <p class="text-center">
              &copy;
                              <a href="http://jpauli.github.io/">Julien Pauli</a>
                            2017
              <small>
                with help from <a href="http://carew.github.com/" target="_blank">Carew</a>
              </small>
            </p>
          </footer>
        
      </div>
    
    
              <script src="../../../js/jquery-2.1.0.min.js"></script>
      <script src="../../../js/bootstrap.min.js"></script>
      <script src="http://yandex.st/highlightjs/8.0/highlight.min.js"></script>
      <script>hljs.initHighlightingOnLoad();</script>
    
      </body>
</html>
